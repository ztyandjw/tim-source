# 客户端启动

org.apache.rocketmq.example.quickstart.Consumer

### Consumer的准备工作

1、初始化 DefaultMQPushConsumer

DefaultMQPushConsumer#DefaultMQPushConsumer(final String consumerGroup)

入参是消费组名称

```java
public DefaultMQPushConsumer(final String consumerGroup) {
    this(null, consumerGroup, null, new AllocateMessageQueueAveragely());
}

```
2、设置命名服务地址、设置消费位置

```java
consumer.setNamesrvAddr("127.0.0.1:9876");
consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);
```

3、订阅

DefaultMQPushConsumer#subscribe(String topic, String subExpression)

```java
@Override
public void subscribe(String topic, String subExpression) throws MQClientException {
    //$1 处理topic名称 @
    //$2 通过topic与表达式进行订阅 @
    this.defaultMQPushConsumerImpl.subscribe(withNamespace(topic), subExpression);
}
```

-------------------------------------------


3.1、 处理topic名称

ClientConfig#withNamespace

```java
public String withNamespace(String resource) {
    return NamespaceUtil.wrapNamespace(this.getNamespace(), resource);
}
```

NamespaceUtil#wrapNamespace(String namespace, String resourceWithOutNamespace)

* 3.1.1 因为namespace为null，所以这里直接返回resourceWithOutNamespace，返回topic名称

```java
public static String wrapNamespace(String namespace, String resourceWithOutNamespace) {

    /$1 因为namespace为null，所以这里直接返回resourceWithOutNamespace，返回topic名称
    if (StringUtils.isEmpty(namespace) || StringUtils.isEmpty(resourceWithOutNamespace)) {
        return resourceWithOutNamespace;
    }

    if (isSystemResource(resourceWithOutNamespace) || isAlreadyWithNamespace(resourceWithOutNamespace, namespace)) {
        return resourceWithOutNamespace;
    }

    String resourceWithoutRetryAndDLQ = withOutRetryAndDLQ(resourceWithOutNamespace);
    StringBuffer strBuffer = new StringBuffer();

    if (isRetryTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.RETRY_GROUP_TOPIC_PREFIX);
    }

    if (isDLQTopic(resourceWithOutNamespace)) {
        strBuffer.append(MixAll.DLQ_GROUP_TOPIC_PREFIX);
    }

    return strBuffer.append(namespace).append(NAMESPACE_SEPARATOR).append(resourceWithoutRetryAndDLQ).toString();

}

```

3.2、通过topic与子表达式进行订阅  

DefaultMQPushConsumerImpl#subscribe(String topic, String subExpression)

* 3.2.1 生成订阅信息 @

* 3.2.2 缓存更新

protected final ConcurrentMap<String /* topic */, SubscriptionData> subscriptionInner =
        new ConcurrentHashMap<String, SubscriptionData>();

* 3.2.3 维持心跳


```java
public void subscribe(String topic, String subExpression) throws MQClientException {
    try {
        //$1  生成订阅数据
        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
            topic, subExpression);
        //$2  缓存更新  @
        this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
        if (this.mQClientFactory != null) {
            //$3  发送心跳 @ TODO
            this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}

```

3.2.1 生成订阅数据

订阅数据里面的属性就是topic，substring，如果substring多个，那么还有2个set，一个是tag名称，另外1个是tag的hashcode

FilterAPI#buildSubscriptionData(final String consumerGroup, String topic, String subString)

* 3.2.1.1  假设substring为null或者equals '*' 或者长度为0，那么设置substring为'*'
* 3.2.1.2 假设substring="A||B",通过split进行分割为数组
* 3.2.1.3 假设每个字符串长度大于0，trim后还是大于0，为啥不直接trim再看长度
* 3.2.1.4 获取tagset，hashset，然后add每个tag名称
* 3.2.1.5 获取codeset，hashset<Integer>，然后添加tag的hashcode

```java
public static SubscriptionData buildSubscriptionData(final String consumerGroup, String topic,
        String subString) throws Exception {
    SubscriptionData subscriptionData = new SubscriptionData();
    subscriptionData.setTopic(topic);
    subscriptionData.setSubString(subString);
    //$1 假设substring为null或者equals '*' 或者长度为0，那么设置substring为'*'
    if (null == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == 0) {
        subscriptionData.setSubString(SubscriptionData.SUB_ALL);
    } else {
        //$2  假设substring="A||B",通过split进行分割为数组
        String[] tags = subString.split("\\|\\|");
        if (tags.length > 0) {
            for (String tag : tags) {
                //$3 假设每个字符串长度大于0，trim后还是大于0，为啥不直接trim再看长度
                if (tag.length() > 0) {
                    String trimString = tag.trim();
                    if (trimString.length() > 0) {
                        //$4 获取tagset，hashset，然后add每个tag名称
                        subscriptionData.getTagsSet().add(trimString);
                        //$5  获取codeset，hashset<Integer>，然后添加tag的hashcode
                        subscriptionData.getCodeSet().add(trimString.hashCode());
                    }
                }
            }
        } else {
            throw new Exception("subString split error");
        }
    }

    return subscriptionData;
}
```
-------------------------------------------

4、注册消息监听器，当消息来了回调

```java
consumer.registerMessageListener(new MessageListenerConcurrently() {

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs,
        ConsumeConcurrentlyContext context) {
        System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});
```

DefaultMQPushConsumer#registerMessageListener(MessageListenerConcurrently messageListener)

```java
@Override
public void registerMessageListener(MessageListenerConcurrently messageListener) {
    this.messageListener = messageListener;
    this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);
}
```
DefaultMQPushConsumerImpl#registerMessageListener(MessageListener messageListener)

```java
public void registerMessageListener(MessageListener messageListener) {
    this.messageListenerInner = messageListener;
}
```





------------------------------------------


### consumer启动

DefaultMQPushConsumerImpl#start

* 1 设置消费组名称
* 2 consumer真正的启动逻辑 @

```java
@Override
public void start() throws MQClientException {
        //$1 设置消费组名称
        setConsumerGroup(NamespaceUtil.wrapNamespace(this.getNamespace(), this.consumerGroup));
        //$2 consumer真正的启动逻辑 @
        this.defaultMQPushConsumerImpl.start();
        if (null != traceDispatcher) {
            try {
                traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
            } catch (MQClientException e) {
                log.warn("trace dispatcher start failed ", e);
            }
        }
}
```
---------------------------------------

2、 consumer真正的启动逻辑


DefaultMQPushConsumerImpl#start()


* 2.1 switch服务状态  private volatile ServiceState serviceState = ServiceState.CREATE_JUST;

* 2.2 检查配置，一些非null检查，若为null则抛出异常

* 2.3 拷贝订阅信息 @

* 2.4 如果是集群模式，那么将instanceId设置为pid @

* 2.5 单例获取mqclientmanager, 获取mqclientInstance 这里mqClientInstance是单例@

* 2.6 rebalanceImpl设置消费组，设置消费类型类型，设置分配策略，设置mqclientInstance

* 2.7 构建拉api的wrapper

* 2.8 如果是消息类型是集群模式，那么offsetStore是远程offsetStore

* 2.9 offset.load()这里是空方法

* 2.10 如果是顺序消费，生成顺序消费服务 @ todo

* 2.11 如果是并发消费，生成并发消费服务

* 2.12 消费服务启动 @ 会另起一个章节 important tim

* 2.13 注册consumer @

* 2.14 消费服务关闭 @ todo

* 2.15 mqclientInstance执行启动方法   @ important tim 重要

* 2.16 更新topic订阅信息  @

* 2.17 检测客户端与broker关联信息 @

* 2.18 维持心跳 @

* 2.19 执行重平衡，重平衡章节介绍


```java
public synchronized void start() throws MQClientException {
    //$2.1 switch服务状态  private volatile ServiceState serviceState = ServiceState.CREATE_JUST;
    switch (this.serviceState) {
        case CREATE_JUST:
            log.info("the consumer [{}] start beginning. messageModel={}, isUnitMode={}", this.defaultMQPushConsumer.getConsumerGroup(),
                this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());
            this.serviceState = ServiceState.START_FAILED;
            //$2.2 检查配置
            this.checkConfig();
            //$2.3 拷贝订阅信息@
            this.copySubscription();
            //$2.4 如果是集群模式，那么将instanceId设置为pid @
            if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
                this.defaultMQPushConsumer.changeInstanceNameToPID();
            }
            //$2.5 单例获取mqclientmanager, 获取mqclientInstance, 这里mqClientInstance是单例 @
            this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);
            //$2.6 rebalanceImpl设置消费组，设置消费类型类型，设置分配策略，设置mqclientInstance
            this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());
            this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());
            this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());
            this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);
            //$2.7 构建拉api的wrapper
            this.pullAPIWrapper = new PullAPIWrapper(
                mQClientFactory,
                this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());
            this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);

            if (this.defaultMQPushConsumer.getOffsetStore() != null) {
                this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();
            } else {
                switch (this.defaultMQPushConsumer.getMessageModel()) {
                    case BROADCASTING:
                        this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    //$2.8 如果是消息类型是集群模式，那么offsetStore是远程offsetStore
                    case CLUSTERING:
                        this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                        break;
                    default:
                        break;
                }
                this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);
            }
            //$2.9 这里是空方法
            this.offsetStore.load();
            //$2.10 如果是顺序消费，生成顺序消费服务 @ todo
            if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
                this.consumeOrderly = true;
                this.consumeMessageService =
                    new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
            
            //$2.11 如果是并发消费，生成并发消费服务
            } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
                this.consumeOrderly = false;
                this.consumeMessageService =
                    new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
            }
            //$2.12 消费服务启动 @ 会另起一个章节 important tim
            this.consumeMessageService.start();
            //$2.13 注册consumer @
            boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
            if (!registerOK) {
                this.serviceState = ServiceState.CREATE_JUST;
                /$2.14 消费服务关闭 @ todo
                this.consumeMessageService.shutdown();
                throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            }
            //$2.15  mqclientInstance执行启动方法   @ important tim 重要
            mQClientFactory.start();
            log.info("the consumer [{}] start OK.", this.defaultMQPushConsumer.getConsumerGroup());
            this.serviceState = ServiceState.RUNNING;
            break;
        case RUNNING:
        case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException("The PushConsumer service state not OK, maybe started once, "
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    }
    //$ 2.16 更新topic订阅信息 @
    this.updateTopicSubscribeInfoWhenSubscriptionChanged();
    //$ 2.17 检测客户端与broker关联信息 @
    this.mQClientFactory.checkClientInBroker();
    //$ 2.18 维持心跳 @
    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
    //$ 2.19 执行重平衡，重平衡章节介绍
    this.mQClientFactory.rebalanceImmediately();
}
```

-----------------------------------

2.3、拷贝订阅信息

sub应该百分百为null，假设是集群模式，生成重试topic订阅信息，放入缓存

DefaultMQPushConsumerImpl#copySubscription()



```java
private void copySubscription() throws MQClientException {
    try {
        Map<String, String> sub = this.defaultMQPushConsumer.getSubscription();
        if (sub != null) {
            for (final Map.Entry<String, String> entry : sub.entrySet()) {
                final String topic = entry.getKey();
                final String subString = entry.getValue();
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    topic, subString);
                this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
            }
        }

        if (null == this.messageListenerInner) {
            this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();
        }

        switch (this.defaultMQPushConsumer.getMessageModel()) {
            case BROADCASTING:
                break;
            case CLUSTERING:
                final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());
                SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                    retryTopic, SubscriptionData.SUB_ALL);
                this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);
                break;
            default:
                break;
        }
    } catch (Exception e) {
        throw new MQClientException("subscription exception", e);
    }
}

```

-----------------------------

2.4 如果是集群模式，那么将instanceId设置为pid

ClientConfig#changeInstanceNameToPID()

```java

public void changeInstanceNameToPID() {
    if (this.instanceName.equals("DEFAULT")) {
        this.instanceName = String.valueOf(UtilAll.getPid());
    }
}
```

UtilAll#getPid()

JMX获取pid

```java
public static int getPid() {
    RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
    String name = runtime.getName(); // format: "pid@hostname"
    try {
        return Integer.parseInt(name.substring(0, name.indexOf('@')));
    } catch (Exception e) {
        return -1;
    }
}
```

------------------------------------------------
2.5、单例获取mqclientmanager, 获取mqclientInstance


MQClientManager

```java
private static MQClientManager instance = new MQClientManager();
public static MQClientManager getInstance() {
    return instance;
}

```

MQClientManager#getOrCreateMQClientInstance(final ClientConfig clientConfig)
```java
public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig) {
    return getOrCreateMQClientInstance(clientConfig, null);
}
```

MQClientManager#getOrCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook)

* 2.5.1 获取clientId @

* 2.5.2 假设缓存中拿到为null，重新生成一个instance  

* 2.5.3 假设putIfAbsent不为null，说明这段时间有其他线程把instance放进去了，那么instance仍然置为pre  important tim
```java

private ConcurrentMap<String/* clientId */, MQClientInstance> factoryTable = new ConcurrentHashMap<String, MQClientInstance>();

public MQClientInstance getOrCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) {
    //$1 获取clientId @
    String clientId = clientConfig.buildMQClientId();
    
    MQClientInstance instance = this.factoryTable.get(clientId);
    if (null == instance) {
        //$2 假设缓存中拿到为null，重新生成一个instance
        instance =
            new MQClientInstance(clientConfig.cloneClientConfig(),
                this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);
        //$3 假设putIfAbsent不为null，说明这段时间有其他线程把instance放进去了，那么instance仍然置为pre @
        MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);
        if (prev != null) {
            instance = prev;
            log.warn("Returned Previous MQClientInstance for clientId:[{}]", clientId);
        } else {
            log.info("Created new MQClientInstance for clientId:[{}]", clientId);
        }
    }

    return instance;
}
```
--------------------------------

2.5.1、 获取clientId @

这里clientid的值为ip@pid2

ClientConfig#buildMQClientId()

```java
public String buildMQClientId() {
    StringBuilder sb = new StringBuilder();
    sb.append(this.getClientIP());

    sb.append("@");
    sb.append(this.getInstanceName());
    if (!UtilAll.isBlank(this.unitName)) {
        sb.append("@");
        sb.append(this.unitName);
    }

    return sb.toString();
}
```
------------------------------------

2.13、 注册consumer

MQClientInstance#registerConsumer

```java
public boolean registerConsumer(final String group, final MQConsumerInner consumer) {
    //$1 假设消费组为null 或者 consumerImpl为null，返回false
    if (null == group || null == consumer) {
        return false;
    }
    //$2 返回prev非null，说明原先已经存在了，那么返回false，说明一个进程针对于同一个消费者组只能启动一个consumer
    MQConsumerInner prev = this.consumerTable.putIfAbsent(group, consumer);
    if (prev != null) {
        log.warn("the consumer group[" + group + "] exist already.");
        return false;
    }

    return true;
}
```

---------------------------


2.15 mqclientInstance执行启动方法   @ important tim 重要

MQClientInstance#start()

* 2.15.1 启动netty客户端 @ todo tim important

* 2.15.2 启动一系列定时任务 @

* 2.15.3 启动pullMessageService 继承ServiceThread @todo

* 2.15.4 启动reblanceService 继承ServiceThread @todo

* 2.15.5 5 consumer也启动producer，不是很明白为啥要这样  @todo

```java
public void start() throws MQClientException {

    synchronized (this) {
        switch (this.serviceState) {
            case CREATE_JUST:
                this.serviceState = ServiceState.START_FAILED;

                if (null == this.clientConfig.getNamesrvAddr()) {
                    this.mQClientAPIImpl.fetchNameServerAddr();
                }
                //$1 启动netty客户端 @
                this.mQClientAPIImpl.start();
                //$2 启动一系列定时任务 @
                this.startScheduledTask();
                //$3 启动pullMessageService 继承ServiceThread @todo
                this.pullMessageService.start();
                //$4 启动reblanceService 继承ServiceThread @todo
                this.rebalanceService.start();    
                //$5 consumer也启动producer，不是很明白为啥要这样  @todo
                this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
                log.info("the client factory [{}] start OK", this.clientId);
                this.serviceState = ServiceState.RUNNING;
                break;
            case START_FAILED:
                throw new MQClientException("The Factory object[" + this.getClientId() + "] has been created before, and failed.", null);
            default:
                break;
        }
    }
}
```

2.15.2 启动一系列定时任务 @

MQClientInstance#startScheduledTask()

* 2.15.2.0 ScheduledExecutorSerivice初始化  important tim

* 2.15.2.1 nameServerAddr肯定设置了，这里不用进去

* 2.15.2.2 更新主题路由信息从Nameserver中 @

* 2.15.2.3 30s进行一次轮训

* 2.15.2.4 清除下线broker @

* 2.15.2.5 持久化消费offset @

* 2.15.2.6 5s更新一下消费进度

* 2.15.2.7 通过计算processQueue中的msg大小，调整线程池大小，@ TODO important tim !!!
```java

//$0 ScheduledExecutorSerivice初始化  important tim
private final ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r, "MQClientFactoryScheduledThread");
    }
});


private void startScheduledTask() {
    //$1 nameServerAddr肯定设置了，这里不用进去
    if (null == this.clientConfig.getNamesrvAddr()) {
        this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

            @Override
            public void run() {
                try {
                    MQClientInstance.this.mQClientAPIImpl.fetchNameServerAddr();
                } catch (Exception e) {
                    log.error("ScheduledTask fetchNameServerAddr exception", e);
                }
            }
        }, 1000 * 10, 1000 * 60 * 2, TimeUnit.MILLISECONDS);
    }

        
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

        @Override
        public void run() {
            try {
                //$2 更新主题路由信息从Nameserver中 @
                MQClientInstance.this.updateTopicRouteInfoFromNameServer();
            } catch (Exception e) {
                log.error("ScheduledTask updateTopicRouteInfoFromNameServer exception", e);
            }
        }
    //$3 30s进行一次，同心跳
    }, 10, this.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);

    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

        @Override
        public void run() {
            try {
                //$4 清除下线broker @
                MQClientInstance.this.cleanOfflineBroker();
                MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();
            } catch (Exception e) {
                log.error("ScheduledTask sendHeartbeatToAllBroker exception", e);
            }
        }
    }, 1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);

    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

        @Override
        public void run() {
            try {
                //$5 持久化消费offset @
                MQClientInstance.this.persistAllConsumerOffset();
            } catch (Exception e) {
                //$6  5s更新一下消费进度
                log.error("ScheduledTask persistAllConsumerOffset exception", e);
            }
        }
    }, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);

    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

        @Override
        public void run() {
            try {
                //$7 通过计算processQueue中的msg大小，调整线程池大小，@ important tim !!!
                MQClientInstance.this.adjustThreadPool();
            } catch (Exception e) {
                log.error("ScheduledTask adjustThreadPool exception", e);
            }
        }
    }, 1, 1, TimeUnit.MINUTES);
}

```

----------------------

2.15.2.2 更新主题路由信息从Nameserver中 @


* 2.15.2.2.1 impl拿Set<SubscriptionData> @

* 2.15.2.2.2 轮训每个topic，更新主题路由信息，假设改动，轮训每个consumer更新其中的topic与Set<MessageQueue>的映射；为什么不从topicRouteTable中拿呢，因为这个并不会主动更新，而是每次调用了updateTopicRouteInfoFromNameserver后，拿到最新的再更新这个缓存的, 2.16.2参考  !!! important tim



首先从全局缓存拿到每个consumerImpl，再拿到每个consumerImpl对应的Set<订阅信息>，
添加到Set<String>中

MQClientInstance#updateTopicRouteInfoFromNameServer

```java
public void updateTopicRouteInfoFromNameServer() {
    Set<String> topicList = new HashSet<String>();

    
    {
        Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();
            Entry<String, MQConsumerInner> entry = it.next();
            MQConsumerInner impl = entry.getValue();
            if (impl != null) {
                //$1 impl拿Set<SubscriptionData>
                Set<SubscriptionData> subList = impl.subscriptions();
                if (subList != null) {
                    for (SubscriptionData subData : subList) {
                        topicList.add(subData.getTopic());
                    }
                }
            }
        while (it.hasNext()) {
        }
    }

    // Producer
    {
        Iterator<Entry<String, MQProducerInner>> it = this.producerTable.entrySet().iterator();
        while (it.hasNext()) {
            Entry<String, MQProducerInner> entry = it.next();
            MQProducerInner impl = entry.getValue();
            if (impl != null) {
                Set<String> lst = impl.getPublishTopicList();
                topicList.addAll(lst);
            }
        }
    }

    for (String topic : topicList) {
        //$2 轮训每个topic，更新主题路由信息，假设改动，轮训每个consumer更新其中的topic与Set<MessageQueue>的映射；为什么不从topicRouteTable中拿呢，因为这个并不会主动更新，而是每次调用了updateTopicRouteInfoFromNameserver后，拿到最新的再更新这个缓存的, 2.16.2参考  !!! important tim

        this.updateTopicRouteInfoFromNameServer(topic);
    }
}

```

--------------------------------

2.15.2.2.1 impl拿Set<SubscriptionData> @

DefaultMQPushConsumerImpl#subscriptions()

```java

@Override
public Set<SubscriptionData> subscriptions() {
    Set<SubscriptionData> subSet = new HashSet<SubscriptionData>();
    subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());
    return subSet;
}

```

-------------------------------

2.15.2.5 持久化消费offset @

MQClientInstance#persistAllConsumerOffset()

```java
private void persistAllConsumerOffset() {

    

    Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<String, MQConsumerInner> entry = it.next();
        MQConsumerInner impl = entry.getValue();
        impl.persistConsumerOffset();
    }
}

```

DefaultMQPushConsumerImpl#persistConsumerOffset()

```java
@Override

protected final ConcurrentMap<MessageQueue, ProcessQueue> processQueueTable = new ConcurrentHashMap<MessageQueue, ProcessQueue>(64);


public void persistConsumerOffset() {
    try {
        this.makeSureStateOK();
        Set<MessageQueue> mqs = new HashSet<MessageQueue>();
        Set<MessageQueue> allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();
        mqs.addAll(allocateMq);

        this.offsetStore.persistAll(mqs);
    } catch (Exception e) {
        log.error("group: " + this.defaultMQPushConsumer.getConsumerGroup() + " persistConsumerOffset exception", e);
    }
}
```

RemoteBrokerOffsetStore#persistAll(Set<MessageQueue> mqs)

* 2.15.2.5.1 MessageQueue与offset的映射

* 2.15.2.5.2 向broker更新消费进度

* 2.15.2.5.3 清理offsetTable中不存在的messageQueue


```java
@Override
public void persistAll(Set<MessageQueue> mqs) {
    if (null == mqs || mqs.isEmpty())
        return;

    final HashSet<MessageQueue> unusedMQ = new HashSet<MessageQueue>();

    //$1 MessageQueue与offset的映射
    for (Map.Entry<MessageQueue, AtomicLong> entry : this.offsetTable.entrySet()) {
        MessageQueue mq = entry.getKey();
        AtomicLong offset = entry.getValue();
        if (offset != null) {
            if (mqs.contains(mq)) {
                try {
                    //$2 向broker更新消费进度
                    this.updateConsumeOffsetToBroker(mq, offset.get());
                    log.info("[persistAll] Group: {} ClientId: {} updateConsumeOffsetToBroker {} {}",
                        this.groupName,
                        this.mQClientFactory.getClientId(),
                        mq,
                        offset.get());
                } catch (Exception e) {
                    log.error("updateConsumeOffsetToBroker exception, " + mq.toString(), e);
                }
            } else {
                unusedMQ.add(mq);
            }
        }
    }
    //$3 清理offsetTable中不存在的messageQueue
    if (!unusedMQ.isEmpty()) {
        for (MessageQueue mq : unusedMQ) {
            this.offsetTable.remove(mq);
            log.info("remove unused mq, {}, {}", mq, this.groupName);
        }
    }
}
```





------------------------------

2.16、 更新topic订阅信息

DefaultMQPushConsumerImpl#updateTopicSubscribeInfoWhenSubscriptionChanged

* 2.16.1 获取topic与订阅数据的映射关系

* 2.16.2 从nameserver更新主题路由信息 @


```java
private void updateTopicSubscribeInfoWhenSubscriptionChanged() {
    //$1 获取topic与订阅数据的映射关系
    Map<String, SubscriptionData> subTable = this.getSubscriptionInner();
    if (subTable != null) {
        for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {
            final String topic = entry.getKey();
            //$2 从nameserver更新主题路由信息
            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);
        }
    }
}
```

------------------------------

2.15.2.4 清除下线broker @


MQClientInstance#cleanOfflineBroker()

* 2.15.2.4.1 private final Lock lockNamesrv = new ReentrantLock();
        //这里为啥要用锁呢，理由是与updateTopicRouteInfo进行互斥操作，假设这里首先判断broker的某个实例已经下线，但是在update里面又添加进去了，然后这里再继续清除，典型aba问题

* 2.15.2.4.2 clone List使用addAll clone map 使用allput

* 2.15.2.4.3  检查这个地址是否在nameserver中  @

* 2.15.2.4.4 假设id与addr的映射为empty，那么iterator remove掉；反之updateTable替换这个brokerName对应的map
* 2.15.2.4.5 一把putAll进行更新

```java
private void cleanOfflineBroker() {
    try {
        //$1 private final Lock lockNamesrv = new ReentrantLock();
        //这里为啥要用锁呢，理由是与updateTopicRouteInfo进行互斥操作，假设这里首先判断broker的某个实例已经下线，但是在update里面又添加进去了，然后这里再继续清除，典型aba问题
        if (this.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS))
            try {
                ConcurrentHashMap<String, HashMap<Long, String>> updatedTable = new ConcurrentHashMap<String, HashMap<Long, String>>();

                Iterator<Entry<String, HashMap<Long, String>>> itBrokerTable = this.brokerAddrTable.entrySet().iterator();
                while (itBrokerTable.hasNext()) {
                    Entry<String, HashMap<Long, String>> entry = itBrokerTable.next();
                    String brokerName = entry.getKey();
                    HashMap<Long, String> oneTable = entry.getValue();
                    //$2 clone List使用addAll clone map 使用allput
                    HashMap<Long, String> cloneAddrTable = new HashMap<Long, String>();
                    cloneAddrTable.putAll(oneTable);

                    Iterator<Entry<Long, String>> it = cloneAddrTable.entrySet().iterator();
                    while (it.hasNext()) {
                        Entry<Long, String> ee = it.next();
                        String addr = ee.getValue();
                        //$3 检查这个地址是否在nameserver中
                        if (!this.isBrokerAddrExistInTopicRouteTable(addr)) {
                            it.remove();
                            log.info("the broker addr[{} {}] is offline, remove it", brokerName, addr);
                        }
                    }
                    //$4 假设id与addr的映射为empty，那么iterator remove掉；反之updateTable替换这个brokerName对应的map
                    if (cloneAddrTable.isEmpty()) {
                        itBrokerTable.remove();
                        log.info("the broker[{}] name's host is offline, remove it", brokerName);
                    } else {
                        updatedTable.put(brokerName, cloneAddrTable);
                    }
                }
                //$5 一把putAll进行更新
                if (!updatedTable.isEmpty()) {
                    this.brokerAddrTable.putAll(updatedTable);
                }
            } finally {
                this.lockNamesrv.unlock();
            }
    } catch (InterruptedException e) {
        log.warn("cleanOfflineBroker Exception", e);
    }
}
```



------------------------------
2.15.2.4.3  检查这个地址是否在nameserver中  @

MQClientInstance#isBrokerAddrExistInTopicRouteTable(final String addr)

```java
private boolean isBrokerAddrExistInTopicRouteTable(final String addr) {
    Iterator<Entry<String, TopicRouteData>> it = this.topicRouteTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<String, TopicRouteData> entry = it.next();
        TopicRouteData topicRouteData = entry.getValue();
        List<BrokerData> bds = topicRouteData.getBrokerDatas();
        for (BrokerData bd : bds) {
            if (bd.getBrokerAddrs() != null) {
                boolean exist = bd.getBrokerAddrs().containsValue(addr);
                if (exist)
                    return true;
            }
        }
    }

    return false;
}
```


----------------



2.16.2、 从nameserver更新主题路由信息 @


MQClientInstance#updateTopicRouteInfoFromNameServer

* 2.16.2.1 private final Lock lockNamesrv = new ReentrantLock(); 支持超时机制

* 2.16.2.2 这个if是进不去的

* 2.16.2.3 调用clientApiImpl从nameserver获取topicRouteData @

* 2.16.2.4 private final ConcurrentMap<String/* Topic */, TopicRouteData> topicRouteTable 从本地缓存看有没有相同topoic对应的TopicRouteData

* 2.16.2.5 检验主题路由信息是否被更改  @

* 2.16.2.6 如果change=false，说明没有改变过

* 2.16.2.7 假设没有改动，是否还需要update @

* 2.16.2.8 循环一个topicRouteData中的brokerData的list，本地broker缓存表进行更新 @

* 2.16.2.9 topicRouteData转换为TopicPublishInfo @

* 2.16.2.10 topicRouteData转换为订阅信息，其实就是List<MessageQueue> @

* 2.16.2.11 key是消费组名称，value为Consumer实例，一个进程这个consumerTable只有一个

* 2.16.2.12 consumer更新路由注册信息 @
```java

public boolean updateTopicRouteInfoFromNameServer(final String topic, boolean isDefault,
    DefaultMQProducer defaultMQProducer) {
    try {
        //$1 private final Lock lockNamesrv = new ReentrantLock(); 支持超时机制
        if (this.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {
            try {
                TopicRouteData topicRouteData;
                //$2 这个判断是进不去的
                if (isDefault && defaultMQProducer != null) {
                    topicRouteData = this.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),
                        1000 * 3);
                    if (topicRouteData != null) {
                        for (QueueData data : topicRouteData.getQueueDatas()) {
                            int queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());
                            data.setReadQueueNums(queueNums);
                            data.setWriteQueueNums(queueNums);
                        }
                    }
                
                } else {
                    //$3 调用clientApiImpl从nameserver获取topicRouteData @
                    topicRouteData = this.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, 1000 * 3);
                }
                
                if (topicRouteData != null) {
                    //$4 private final ConcurrentMap<String/* Topic */, TopicRouteData> topicRouteTable 从本地缓存看有没有相同topoic对应的TopicRouteData
                    TopicRouteData old = this.topicRouteTable.get(topic);
                    //$5 检验主题路由信息是否被更改  @
                    boolean changed = topicRouteDataIsChange(old, topicRouteData);
                    //$6 如果change=false，说明没有改变过
                    if (!changed) {
                        //$7 假设没有改动，是否还需要update @
                        changed = this.isNeedUpdateTopicRouteInfo(topic);
                    } else {
                        log.info("the topic[{}] route info changed, old[{}] ,new[{}]", topic, old, topicRouteData);
                    }

                    if (changed) {
                        TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();

                        for (BrokerData bd : topicRouteData.getBrokerDatas()) {
                            //$8  循环一个topicRouteData中的brokerData的list，本地broker缓存表进行更新 @
                            this.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());
                        }

                        // Update Pub info
                        {
                            //$9 topicRouteData转换为TopicPublishInfo @
                            TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);
                            publishInfo.setHaveTopicRouterInfo(true);
                            Iterator<Entry<String, MQProducerInner>> it = this.producerTable.entrySet().iterator();
                            while (it.hasNext()) {
                                Entry<String, MQProducerInner> entry = it.next();
                                MQProducerInner impl = entry.getValue();
                                if (impl != null) {
                                    impl.updateTopicPublishInfo(topic, publishInfo);
                                }
                            }
                        }

                        // Update sub info
                        {
                            //$10 topicRouteData转换为订阅信息，其实就是List<MessageQueue>
                            Set<MessageQueue> subscribeInfo = topicRouteData2TopicSubscribeInfo(topic, topicRouteData);
                            //$11 key是消费组名称，value为Consumer实例，一个进程这个consumerTable只有一个
                            Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();
                            while (it.hasNext()) {
                                Entry<String, MQConsumerInner> entry = it.next();
                                MQConsumerInner impl = entry.getValue();
                                if (impl != null) {
                                    //$12 consumer更新路由注册信息 @
                                    impl.updateTopicSubscribeInfo(topic, subscribeInfo);
                                }
                            }
                        }
                        log.info("topicRouteTable.put. Topic = {}, TopicRouteData[{}]", topic, cloneTopicRouteData);
                        //$13 因为changed了，更新topicRouteTable的topic对应的topicRouteData，这个topicRouteTable是
                        一个进程一个，单例里面的属性,最后返回true
                        this.topicRouteTable.put(topic, cloneTopicRouteData);
                        return true;
                    }
                } else {
                    log.warn("updateTopicRouteInfoFromNameServer, getTopicRouteInfoFromNameServer return null, Topic: {}", topic);
                }
            } catch (MQClientException e) {
                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX) && !topic.equals(MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC)) {
                    log.warn("updateTopicRouteInfoFromNameServer Exception", e);
                }
            } catch (RemotingException e) {
                log.error("updateTopicRouteInfoFromNameServer Exception", e);
                throw new IllegalStateException(e);
            } finally {
                this.lockNamesrv.unlock();
            }
        } else {
            log.warn("updateTopicRouteInfoFromNameServer tryLock timeout {}ms", LOCK_TIMEOUT_MILLIS);
        }
    } catch (InterruptedException e) {
        log.warn("updateTopicRouteInfoFromNameServer Exception", e);
    }

    return false;
}

```




---------------------------------------------

2.16.2.5 检验主题路由信息是否被更改  @

* 2.16.2.5.1 假设老的topicRouteData为null，说明变动过了，返回true

* 2.16.2.5.2 clone新的topicRouteData，为了避免不要将老的改动 @

* 2.16.2.5.3 因为是最终需要equals，里面涉及list的的equals，所以要将新老topicRouteData进行排序
其中实体类实现Comparable<BrokerData>，重写 comapreTo(BrokerData)方法

* 2.16.2.5.4 equals比较新老topicRouteData是否一致 @


MQClientInstance#topicRouteDataIsChange(opicRouteData olddata, TopicRouteData nowdata)

```java
private boolean topicRouteDataIsChange(TopicRouteData olddata, TopicRouteData nowdata) {
    //$1 假设老的topicRouteData为null，说明变动过了，返回true
    if (olddata == null || nowdata == null)
        return true;
    //$2 clone新的topicRouteData，为了避免不要将老的改动 @
    TopicRouteData old = olddata.cloneTopicRouteData();
    TopicRouteData now = nowdata.cloneTopicRouteData();
    //$3 因为是最终需要equals，里面涉及list的的equals，所以要将新老topicRouteData进行排序
    //其中实体类实现Comparable<BrokerData>，重写 comapreTo(BrokerData)方法
    Collections.sort(old.getQueueDatas());
    Collections.sort(old.getBrokerDatas());
    Collections.sort(now.getQueueDatas());
    Collections.sort(now.getBrokerDatas());
    //$4 equals比较新老topicRouteData是否一致 @
    return !old.equals(now);

}
```
2.16.2.5.2 clone新的topicRouteData，为了避免不要将老的改动 @


TopicRouteData#cloneTopicRouteData()

```java
public TopicRouteData cloneTopicRouteData() {
    TopicRouteData topicRouteData = new TopicRouteData();
    topicRouteData.setQueueDatas(new ArrayList<QueueData>());
    topicRouteData.setBrokerDatas(new ArrayList<BrokerData>());
    topicRouteData.setFilterServerTable(new HashMap<String, List<String>>());
    topicRouteData.setOrderTopicConf(this.orderTopicConf);

    if (this.queueDatas != null) {
        topicRouteData.getQueueDatas().addAll(this.queueDatas);
    }

    if (this.brokerDatas != null) {
        topicRouteData.getBrokerDatas().addAll(this.brokerDatas);
    }

    if (this.filterServerTable != null) {
        topicRouteData.getFilterServerTable().putAll(this.filterServerTable);
    }

    return topicRouteData;
}
```

--------------------------------

2.16.2.5.4 equals比较新老topicRouteData是否一致 @

TopicRouteData#hashCode()

```java
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((brokerDatas == null) ? 0 : brokerDatas.hashCode());
    result = prime * result + ((orderTopicConf == null) ? 0 : orderTopicConf.hashCode());
    result = prime * result + ((queueDatas == null) ? 0 : queueDatas.hashCode());
    result = prime * result + ((filterServerTable == null) ? 0 : filterServerTable.hashCode());
    return result;
}


```

TopicRouteData#equals()

```java
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    TopicRouteData other = (TopicRouteData) obj;
    if (brokerDatas == null) {
        if (other.brokerDatas != null)
            return false;
    } else if (!brokerDatas.equals(other.brokerDatas))
        return false;
    if (orderTopicConf == null) {
        if (other.orderTopicConf != null)
            return false;
    } else if (!orderTopicConf.equals(other.orderTopicConf))
        return false;
    if (queueDatas == null) {
        if (other.queueDatas != null)
            return false;
    } else if (!queueDatas.equals(other.queueDatas))
        return false;
    if (filterServerTable == null) {
        if (other.filterServerTable != null)
            return false;
    } else if (!filterServerTable.equals(other.filterServerTable))
        return false;
    return true;
}
```

-------------------------------------------------------------------------

2.16.2.7 假设没有改动，是否还需要update @

* 2.16.2.7.1 由于这里是consumer，忽略这里
* 2.16.2.7.2 检验是否需要更新 @

MQClientInstance#isNeedUpdateTopicRouteInfo(final String topic)

```java
private boolean isNeedUpdateTopicRouteInfo(final String topic) {
    boolean result = false;
    //$1 由于这里是consumer，忽略这里
    {

        Iterator<Entry<String, MQProducerInner>> it = this.producerTable.entrySet().iterator();
        while (it.hasNext() && !result) {
            Entry<String, MQProducerInner> entry = it.next();
            MQProducerInner impl = entry.getValue();
            if (impl != null) {
                result = impl.isPublishTopicNeedUpdate(topic);
            }
        }
    }

    {
        Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();
        while (it.hasNext() && !result) {
            Entry<String, MQConsumerInner> entry = it.next();
            MQConsumerInner impl = entry.getValue();
            if (impl != null) {
                //$2 检验是否需要更新 @
                result = impl.isSubscribeTopicNeedUpdate(topic);
            }
        }
    }

    return result;
}
```

-------------------------

2.16.2.7.2 检验主题订阅信息是否需要更新 @

DefaultMQPushConsumerImpl#isSubscribeTopicNeedUpdate(String topic)

首先检查subscriptioninner有没有该topic的订阅data，如果有，再查topicSubscribeInfoTable包含不包含这个topic
如果包含，返回false，无需更新，如果不包含，返回true；如果subTable为null或者查不到，说明该consumer没有订阅该主题

```java
public boolean isSubscribeTopicNeedUpdate(String topic) {
    Map<String, SubscriptionData> subTable = this.getSubscriptionInner();
    if (subTable != null) {
        if (subTable.containsKey(topic)) {
            return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);
        }
    }

    return false;
}
```

---------------------------------

2.16.2.8 循环一个topicRouteData中的brokerData的list，本地broker缓存表进行更新 @

MQClientInstance@brokerAddrTable

```java
private final ConcurrentMap<String/* Broker Name */, HashMap<Long/* brokerId */, String/* address */>> brokerAddrTable = new ConcurrentHashMap<String, HashMap<Long, String>>();
```

----------------------------------

2.16.2.9 topicRouteData转换为TopicPublishInfo @  这里其实不需要分析，以为是consumer


MQClientInstance#topicRouteData2TopicPublishInfo(final String topic, final TopicRouteData route)

* 2.16.2.9.1 这里为null 跳过

* 2.16.2.9.2 一个queueData对应一个broker，查看这个queueData是否可写 @

* 2.16.2.9.3 假设brker不是master ignore

* 2.16.2.9.4 生成MessageQueue，这个是客户端的方的抽象

* 2.16.2.9.5 将messageQueue添加进入topicPublishInfo的list

```java
public static TopicPublishInfo topicRouteData2TopicPublishInfo(final String topic, final TopicRouteData route) {
    TopicPublishInfo info = new TopicPublishInfo();
    info.setTopicRouteData(route);
    //$1 这里为null，跳过
    if (route.getOrderTopicConf() != null && route.getOrderTopicConf().length() > 0) {
        String[] brokers = route.getOrderTopicConf().split(";");
        for (String broker : brokers) {
            String[] item = broker.split(":");
            int nums = Integer.parseInt(item[1]);
            for (int i = 0; i < nums; i++) {
                MessageQueue mq = new MessageQueue(topic, item[0], i);
                info.getMessageQueueList().add(mq);
            }
        }

        info.setOrderTopic(true);
    } else {
        List<QueueData> qds = route.getQueueDatas();
        Collections.sort(qds);
        for (QueueData qd : qds) {
            //$2 一个queueData对应一个broker，查看这个queueData是否可写
            if (PermName.isWriteable(qd.getPerm())) {
                BrokerData brokerData = null;
                for (BrokerData bd : route.getBrokerDatas()) {
                    if (bd.getBrokerName().equals(qd.getBrokerName())) {
                        brokerData = bd;
                        break;
                    }
                }

                if (null == brokerData) {
                    continue;
                }
                //$3 假设brker不是master ignore
                if (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) {
                    continue;
                }

                for (int i = 0; i < qd.getWriteQueueNums(); i++) {
                    //$4 生成MessageQueue，这个是客户端的方的抽象
                    MessageQueue mq = new MessageQueue(topic, qd.getBrokerName(), i);
                    //$5 将messageQueue添加进入topicPublishInfo的list
                    info.getMessageQueueList().add(mq);
                }
            }
        }

        info.setOrderTopic(false);
    }

    return info;
}
```

------------------------

2.16.2.9.2 一个queueData对应一个broker，查看这个queueData是否可写 @

PermName#isWriteable(final int perm)

```java

public static final int PERM_WRITE = 0x1 << 1;

public static boolean isWriteable(final int perm) {
    return (perm & PERM_WRITE) == PERM_WRITE;
}
```


----------------------------------------------

2.16.2.10 topicRouteData转换为订阅信息，其实就是List<MessageQueue> @

MQClientInstance#topicRouteData2TopicSubscribeInfo(final String topic, final TopicRouteData route)

每一个QueueData代表一组broker(主从)下面的queue信息

* 2.16.2.10.1 假设这个broker是可读的 @

```java
public static Set<MessageQueue> topicRouteData2TopicSubscribeInfo(final String topic, final TopicRouteData route) {
    Set<MessageQueue> mqList = new HashSet<MessageQueue>();
    List<QueueData> qds = route.getQueueDatas();
    for (QueueData qd : qds) {
        //$1 假设这个broker是可读的
        if (PermName.isReadable(qd.getPerm())) {
            for (int i = 0; i < qd.getReadQueueNums(); i++) {
                MessageQueue mq = new MessageQueue(topic, qd.getBrokerName(), i);
                mqList.add(mq);
            }
        }
    }

    return mqList;
}
```

2.16.2.10.1 假设这个broker是可读的 @

PermName#isReadable(final int perm)

```java

public static final int PERM_READ = 0x1 << 2;


public static boolean isReadable(final int perm) {
    return (perm & PERM_READ) == PERM_READ;
}

```




----------------------------

2.16.2.12 consumer更新路由注册信息 @

* 2.16.2.12.1 topic与订阅data的映射，1个consumer1个，key为不同topic
* 2.16.2.12.2 假设这个consumer曾经注册过这个topic，那么更新topicSubscribeInfoTable这个映射表，topic与messagequeue集合额映射 @

DefaultMQPushConsumerImpl#updateTopicSubscribeInfo(String topic, Set<MessageQueue> info)

```java
@Override
public void updateTopicSubscribeInfo(String topic, Set<MessageQueue> info) {
    //$1 topic与订阅data的映射，1个consumer1个，key为不同topic
    Map<String, SubscriptionData> subTable = this.getSubscriptionInner();
    if (subTable != null) {
        //$2 假设这个consumer曾经注册过这个topic，那么更新topicSubscribeInfoTable这个映射表，topic与messagequeue集合额映射 @
        if (subTable.containsKey(topic)) {
            this.rebalanceImpl.topicSubscribeInfoTable.put(topic, info);
        }
    }
}


```











2、注册consumer

DefaultMQPushConsumerImpl#start

* 2.1 注册consumer @

```java

//$1 注册consumer
boolean registerOK = mQClientFactory.registerConsumer(
this.defaultMQPushConsumer.getConsumerGroup(), this);
if (!registerOK) {
    this.serviceState = ServiceState.CREATE_JUST;
    this.consumeMessageService.shutdown();
    throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
        + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
        null);
}
```

------------------------------



2.17 检测客户端与broker关联信息 @

由于案例中tagType一定与isTagType一致，所以这里啥都不会做

MQClientInstance#checkClientInBroker()

```java
public void checkClientInBroker() throws MQClientException {
    Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();

    while (it.hasNext()) {
        Entry<String, MQConsumerInner> entry = it.next();
        Set<SubscriptionData> subscriptionInner = entry.getValue().subscriptions();
        if (subscriptionInner == null || subscriptionInner.isEmpty()) {
            return;
        }

        for (SubscriptionData subscriptionData : subscriptionInner) {
            if (ExpressionType.isTagType(subscriptionData.getExpressionType())) {
                continue;
            }
            // may need to check one broker every cluster...
            // assume that the configs of every broker in cluster are the the same.
            String addr = findBrokerAddrByTopic(subscriptionData.getTopic());

            if (addr != null) {
                try {
                    this.getMQClientAPIImpl().checkClientInBroker(
                        addr, entry.getKey(), this.clientId, subscriptionData, 3 * 1000
                    );
                } catch (Exception e) {
                    if (e instanceof MQClientException) {
                        throw (MQClientException) e;
                    } else {
                        throw new MQClientException("Check client in broker error, maybe because you use "
                            + subscriptionData.getExpressionType() + " to filter message, but server has not been upgraded to support!"
                            + "This error would not affect the launch of consumer, but may has impact on message receiving if you " +
                            "have use the new features which are not supported by server, please check the log!", e);
                    }
                }
            }
        }
    }
}
```

----------------------------------------

2.18、 维持心跳 @

MQClientInstance#sendHeartbeatToAllBrokerWithLock()

* 2.18.1 心跳 @
* 2.18.2 fiter相关  @todo

```java
public void sendHeartbeatToAllBrokerWithLock() {
    if (this.lockHeartbeat.tryLock()) {
        try {
            //$1 心跳 @
            this.sendHeartbeatToAllBroker();
            //$2 fiter相关  @todo
            this.uploadFilterClassSource();
        } catch (final Exception e) {
            log.error("sendHeartbeatToAllBroker exception", e);
        } finally {
            this.lockHeartbeat.unlock();
        }
    } else {
        log.warn("lock heartBeat, but failed.");
    }
}
```

MQClientInstance#sendHeartbeatToAllBroker

```java

```

------------------------------------

2.18.1 心跳 @

MQClientInstance#sendHeartbeatToAllBroker()


* 2.18.1.1  生成心跳数据 @

* 2.18.1.2 假设producer和consumer都为空，那么也别发心跳了

* 2.18.1.3 brokerAddrTable，key为broker名称，值为map，key为id，值为地址，相同broker名称的broker是才能组成主备

* 2.18.1.4 说明改进程只有provider，那么只能与master发送心跳

* 2.18.1.5 brokerVersionTable是broker名称与地址版本的映射

* 2.18.1.6 如果是20的整数倍，那么log输出

* 2.18.1.7 这个brokerAddress是否在命名服务器中 @

```java
private void sendHeartbeatToAllBroker() {
    //$1 生成心跳数据 @
    final HeartbeatData heartbeatData = this.prepareHeartbeatData();
    final boolean producerEmpty = heartbeatData.getProducerDataSet().isEmpty();
    final boolean consumerEmpty = heartbeatData.getConsumerDataSet().isEmpty();
    //$2 假设producer和consumer都为空，那么也别发心跳了
    if (producerEmpty && consumerEmpty) {
        log.warn("sending heartbeat, but no consumer and no producer");
        return;
    }

    if (!this.brokerAddrTable.isEmpty()) {
        long times = this.sendHeartbeatTimesTotal.getAndIncrement();
        //$3 brokerAddrTable，key为broker名称，值为map，key为id，值为地址，相同broker名称的broker是才能组成主备
        Iterator<Entry<String, HashMap<Long, String>>> it = this.brokerAddrTable.entrySet().iterator();
        while (it.hasNext()) {
            Entry<String, HashMap<Long, String>> entry = it.next();
            String brokerName = entry.getKey();
            HashMap<Long, String> oneTable = entry.getValue();
            if (oneTable != null) {
                for (Map.Entry<Long, String> entry1 : oneTable.entrySet()) {
                    Long id = entry1.getKey();
                    String addr = entry1.getValue();
                    if (addr != null) {
                        //$4 说明改进程只有provider，那么只能与master发送心跳
                        if (consumerEmpty) {
                            if (id != MixAll.MASTER_ID)
                                continue;
                        }

                        try {
                            int version = this.mQClientAPIImpl.sendHearbeat(addr, heartbeatData, 3000);
                            if (!this.brokerVersionTable.containsKey(brokerName)) {
                                this.brokerVersionTable.put(brokerName, new HashMap<String, Integer>(4));
                            }
                            //$5 brokerVersionTable是broker名称与地址版本的映射
                            this.brokerVersionTable.get(brokerName).put(addr, version);
                            //$6 如果是20的整数倍，那么log输出
                            if (times % 20 == 0) {
                                log.info("send heart beat to broker[{} {} {}] success", brokerName, id, addr);
                                log.info(heartbeatData.toString());
                            }
                        } catch (Exception e) {
                            //$7 这个brokerAddress是否在命名服务器中 @
                            if (this.isBrokerInNameServer(addr)) {
                                log.info("send heart beat to broker[{} {} {}] failed", brokerName, id, addr, e);
                            } else {
                                log.info("send heart beat to broker[{} {} {}] exception, because the broker not up, forget it", brokerName,
                                    id, addr, e);
                            }
                        }
                    }
                }
            }
        }
    }
}

```

2.18.1.1  生成心跳数据 @

* 2.18.1.1.1 consumerTable全进程唯一，key为consumerGroup，值为consumerImpl
* 2.18.1.1.2 ConsumerData创建，消费组名称，消费类型(PULL/PUSH),消息类型(BROADCASTING/CLUSTER)
消费位置，订阅数据集合，unitModel 默认false

MQClientInstance#prepareHeartbeatData()

```java
private HeartbeatData prepareHeartbeatData() {
    HeartbeatData heartbeatData = new HeartbeatData();
    heartbeatData.setClientID(this.clientId);

    //$1 consumerTable全进程唯一，key为consumerGroup，值为consumerImpl
    for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
        MQConsumerInner impl = entry.getValue();
        if (impl != null) {
            //$2 ConsumerData创建，消费组名称，消费类型(PULL/PUSH),消息类型(BROADCASTING/CLUSTER)
            //消费位置，订阅数据集合，unitModel 默认false
            ConsumerData consumerData = new ConsumerData();
            consumerData.setGroupName(impl.groupName());
            consumerData.setConsumeType(impl.consumeType());
            consumerData.setMessageModel(impl.messageModel());
            consumerData.setConsumeFromWhere(impl.consumeFromWhere());
            consumerData.getSubscriptionDataSet().addAll(impl.subscriptions());
            consumerData.setUnitMode(impl.isUnitMode());
            //$3 heartBeatData存在consumerDataSet，添加当前consumerData
            heartbeatData.getConsumerDataSet().add(consumerData);
        }
    }

    // Producer
    for (Map.Entry<String/* group */, MQProducerInner> entry : this.producerTable.entrySet()) {
        MQProducerInner impl = entry.getValue();
        if (impl != null) {
            ProducerData producerData = new ProducerData();
            producerData.setGroupName(entry.getKey());

            heartbeatData.getProducerDataSet().add(producerData);
        }
    }

    return heartbeatData;
}

```

----------------------------------

2.18.1.7 这个brokerAddress是否在命名服务器中 @

MQClientInstance#isBrokerInNameServer(final String brokerAddr)

因为topicRouteTable是根据访问nameserver获得的。获取所有的topicRouteData，遍历每个topicRouteData，
从中获得List<BrokerData>，轮询每个brokerdata，拿到其中的brokerAddrs，这是个map<brokerId, brokerAddress>
检查这个map是否containsValue(brokerAddr)，如果包含返回true

```java

private boolean isBrokerInNameServer(final String brokerAddr) {
    Iterator<Entry<String, TopicRouteData>> it = this.topicRouteTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry<String, TopicRouteData> itNext = it.next();
        List<BrokerData> brokerDatas = itNext.getValue().getBrokerDatas();
        for (BrokerData bd : brokerDatas) {
            boolean contain = bd.getBrokerAddrs().containsValue(brokerAddr);
            if (contain)
                return true;
        }
    }

    return false;
}
```



